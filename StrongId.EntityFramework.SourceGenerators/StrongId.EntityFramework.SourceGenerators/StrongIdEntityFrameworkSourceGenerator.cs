using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using StrongId.EntityFramework.SourceGenerators.Models;


namespace StrongId.EntityFramework.SourceGenerators;

[Generator]
public class StrongIdEntityFrameworkSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new StrongIdEntityFrameworkSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        
        if (context.SyntaxReceiver is not StrongIdEntityFrameworkSyntaxReceiver receiver)
        {
            return;
        }
        
        List<StrongIdIngredients> ingredients = [];
        foreach (var assembly in context.Compilation.SourceModule.ReferencedAssemblySymbols)
        {
            foreach (var type in GetAllTypes(assembly.GlobalNamespace))
            {
                if (type.TypeKind != TypeKind.Class) continue;

                foreach (var attribute in type.GetAttributes())
                {
                    if (attribute.AttributeClass is null || 
                        (attribute.AttributeClass.Name.EndsWith("StrongId") ||  attribute.AttributeClass.Name.EndsWith("StrongIdAttribute")) is false) 
                        continue;
                    
                    
                    bool foundType = false;
                    foreach (var namedArgument in attribute.NamedArguments)
                    {
                        object? value = namedArgument.Value.Value;

                        if (value is ITypeSymbol typeSymbol)
                        {
                            var text = typeSymbol.ToDisplayString();
                            string nms = type.ToDisplayString();
                            var dot = nms.LastIndexOf('.');
                            nms = nms.Substring(0, dot);
                            
                            var ingredient = new StrongIdIngredients(nms, [], type.Name, new StrongIdParameters(text, ""));
                            ingredients.Add(ingredient);
                            foundType = true;
                            break;
                        }
                    }

                    if (foundType is false)
                    {
                        string nms = type.ToDisplayString();
                        var dot = nms.LastIndexOf('.');
                        nms = nms.Substring(0, dot);
                        
                        //type.ContainingNamespace.Name
                        var ingredient = new StrongIdIngredients(nms, [], type.Name, new StrongIdParameters("System.Guid", ""));
                        ingredients.Add(ingredient);
                    }

                    break;
                }
            }
        }
        
            

        ingredients.AddRange(receiver.Ingredients);
        foreach (var ingredient in ingredients)
        {
            // Generate converter class
            var converter = GenerateStrongIdConverterClass(ingredient);
            context.AddSource($"{context.Compilation.AssemblyName}{ingredient.Class}IdConverter.g.cs", converter);
        }

        if (ingredients.Any())
        {
            var extensionMethod = GenerateExtensionMethod(ingredients);
            context.AddSource($"{context.Compilation.AssemblyName}StrongIdEntityFrameworkExtensions.g.cs", extensionMethod);
        }
    }
    
    
    
    static IEnumerable<INamedTypeSymbol> GetAllTypes(INamespaceSymbol ns)
    {
        foreach (var type in ns.GetTypeMembers())
            yield return type;

        foreach (var nestedNs in ns.GetNamespaceMembers())
        foreach (var t in GetAllTypes(nestedNs))
            yield return t;
    }

    private static string GenerateExtensionMethod(List<StrongIdIngredients> ingredients)
    {
        StringBuilder builder = new();
        builder.AppendLine("""
                           // <auto-generated/>
                           using Microsoft.EntityFrameworkCore;
                           using StrongId.EntityFramework.Converters;
                           """);

        foreach (var @namespace in ingredients.Select(x => x.Namespace).Distinct())
        {
            builder.AppendLine($"using {@namespace};");
        }

        builder.AppendLine($$"""

                           namespace StrongId.EntityFramework.Extensions;

                           internal static class StrongIdEntityFrameworkExtensions
                           {
                           {{'\t'}}extension(ModelConfigurationBuilder configurationBuilder)
                           {{'\t'}}{
                           {{'\t'}}{{'\t'}}internal void AddStrongIdConverters()
                           {{'\t'}}{{'\t'}}{
                           """);


        foreach (var ingredient in ingredients)
        {
            builder.AppendLine(
                $"""
                 {'\t'}{'\t'}{'\t'}configurationBuilder.Properties<{ingredient.Class}Id>()
                 {'\t'}{'\t'}{'\t'}  .HaveConversion<{ingredient.Class}IdConverter>();

                 """);
        }


        builder.AppendLine($$"""
                             {{'\t'}}{{'\t'}}}
                             {{'\t'}}}
                             }
                             """);

        return builder.ToString();
    }


    private static string GenerateStrongIdConverterClass(StrongIdIngredients ingredients)
    {
        var strBuilder = new StringBuilder();

        strBuilder.AppendLine($"""
                               // <auto-generated/>

                               using {ingredients.Namespace};
                               using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

                               namespace StrongId.EntityFramework.Converters;

                               internal sealed class {ingredients.Class}IdConverter() : ValueConverter<{ingredients.Class}Id, {ingredients.Parameters.ParameterType}>
                               (x => x.Value, x => {ingredients.Class}Id.Create(x));
                               """);

        return strBuilder.ToString();
    }
}