using System;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace StrongId.SourceGenerators;

[Generator]
public class StrongIdIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string FullyQualifiedIdentifier = "StrongId.Attributes.StrongIdAttribute";
    private const string Identifier = "StrongId";

    private record Information(string ClassName, string ClassNamespace, string PropertyType, string PropertyName)
    {
        public string ClassName { get; } = ClassName;
        public string ClassNamespace { get; } = ClassNamespace;
        public string PropertyType { get; } = PropertyType;
        public string PropertyName { get; } = PropertyName;
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(FullyQualifiedIdentifier,
            static (_, _) => true,
            static (ctx, _) => GetInformationFromNode(ctx));

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static Information GetInformationFromNode(GeneratorAttributeSyntaxContext context)
    {
        string classNamespace = context.TargetSymbol.ContainingNamespace.ToString();
        var className = context.TargetSymbol.Name;
        string propertyType = "System.Guid";
        string propertyName = "Id";

        foreach (var attribute in context.TargetSymbol.GetAttributes())
        {
            if (attribute.AttributeClass?.Name.Contains(Identifier) is false) continue;
            
            var syntax = attribute.ApplicationSyntaxReference!.GetSyntax();
            var attributeData = GetAttributeParameters((AttributeSyntax)syntax);
            propertyName = attributeData.name;
            propertyType = attributeData.type;
            break;
        }

        return new Information(className, classNamespace, propertyType, propertyName);
    }

    private static (string type, string name) GetAttributeParameters(AttributeSyntax attribute)
        {
            string parametertype = "System.Guid";
            string parameterName = "Id";
    
            var arguments = attribute.ArgumentList?.Arguments ?? [];
            foreach (var syntax in arguments)
            {
                var parameter = syntax.NameEquals?.Name.ToString() ?? string.Empty;
    
                switch (parameter)
                {
                    case "ParameterType":
                    {
                        var expression = syntax.Expression.ToString();
                        parametertype = expression
                            .Trim()
                            .Substring(7, expression.Length - 8);
                        break;
                    }
    
                    case "ParameterName":
                    {
                        parameterName = syntax.Expression.ToString()
                            .Trim('"');
                        break;
                    }
                }
            }
    
            return new ValueTuple<string,string>(parametertype, parameterName);
        }
    
    
    
    private static void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<Information> informations)
    {
        foreach (var information in informations)
        {
            // Partial
            context.AddSource(information.ClassName + $".g.cs",
                $$"""
                  // <auto-generated/>

                  using System;

                  namespace {{information.ClassNamespace}};

                  partial class {{information.ClassName}}
                  {
                  {{'\t'}}public {{information.ClassName}}Id {{information.PropertyName}} { get; private set; }
                  }
                  
                  """);
            
            // Record
            context.AddSource(information.ClassName + $"Id.g.cs",
                $$"""
                  // <auto-generated/>
                  
                  using System;
                  
                  namespace {{information.ClassNamespace}};
                  
                  public readonly record struct {{information.ClassName}}Id
                  {
                  {{'\t'}}public required {{information.PropertyType}} Value { get; init; }
                  
                  {{'\t'}}public static {{information.ClassName}}Id Create({{information.PropertyType}} id) => new {{information.ClassName}}Id
                  {{'\t'}}{
                  {{'\t'}}{{'\t'}}Value = id
                  {{'\t'}}};
                  }
                  
                  """);
        }
    }
}